import { mkdir, writeFile } from 'fs/promises';
import { join } from 'path';
import { existsSync } from 'fs';
import { ReportData, CheckError, ErrorType } from '../types/index.js';

/**
 * Format duration in seconds to human-readable format
 */
function formatDuration(seconds: number): string {
  if (seconds < 60) {
    return `${seconds} seconds`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes} minutes ${remainingSeconds} seconds`;
}

/**
 * Group errors by type
 */
function groupErrorsByType(errors: CheckError[]): Map<ErrorType, CheckError[]> {
  const grouped = new Map<ErrorType, CheckError[]>();

  for (const error of errors) {
    if (!grouped.has(error.type)) {
      grouped.set(error.type, []);
    }
    grouped.get(error.type)!.push(error);
  }

  return grouped;
}

/**
 * Generate markdown report
 */
export function generateMarkdownReport(reportData: ReportData): string {
  const { config, stats, errors, timestamp } = reportData;
  const duration = stats.endTime
    ? Math.floor((stats.endTime - stats.startTime) / 1000)
    : 0;

  let markdown = '# check-shipment Report\n\n';

  // Metadata
  markdown += `**Date:** ${timestamp}\n`;
  markdown += `**Start URL:** ${config.url}\n`;
  markdown += `**Duration:** ${formatDuration(duration)}\n\n`;

  // Summary
  markdown += '## Summary\n\n';
  markdown += `- **Total Pages Crawled:** ${stats.pagesCrawled}\n`;
  markdown += `- **Total Links Checked:** ${stats.linksChecked}\n`;
  markdown += `- **Total Links Skipped:** ${stats.skippedLinks}\n`;
  markdown += `- **Broken Links Found:** ${stats.brokenLinks}\n`;

  if (stats.linksChecked > 0) {
    const successRate = ((stats.linksChecked - stats.brokenLinks) / stats.linksChecked * 100).toFixed(1);
    markdown += `- **Success Rate:** ${successRate}%\n`;
  }

  markdown += '\n';

  // If no errors, add success message
  if (errors.length === 0) {
    markdown += '## Result\n\n';
    markdown += 'âœ… **No broken links found!**\n\n';
    markdown += 'All links on your website are working correctly.\n\n';
  } else {
    // Group errors by type
    const groupedErrors = groupErrorsByType(errors);

    markdown += '## Broken Links\n\n';

    for (const [errorType, errorList] of groupedErrors) {
      markdown += `### ${errorType} (${errorList.length})\n\n`;
      markdown += '| Broken URL | Source Page |\n';
      markdown += '|------------|-------------|\n';

      for (const error of errorList) {
        const brokenUrl = error.url;
        const sourcePages = error.sourcePages.length > 0
          ? error.sourcePages.join('<br>')
          : 'N/A';

        markdown += `| ${brokenUrl} | ${sourcePages} |\n`;
      }

      markdown += '\n';
    }
  }

  // Footer
  markdown += '---\n\n';
  markdown += '*Generated by check-shipment v1.2.0*\n';

  return markdown;
}

/**
 * Save markdown report to file
 */
export async function saveMarkdownReport(reportData: ReportData): Promise<string> {
  const reportDir = join(process.cwd(), '.check-shipment');

  // Create report directory if it doesn't exist
  if (!existsSync(reportDir)) {
    await mkdir(reportDir, { recursive: true });
  }

  // Generate filename with timestamp
  const date = new Date();
  const timestamp = date.toISOString().replace(/[:.]/g, '-').split('T')[0] + '-' +
                    date.toTimeString().split(' ')[0].replace(/:/g, '-');
  const filename = `report-${timestamp}.md`;
  const filepath = join(reportDir, filename);

  // Generate and save report
  const markdown = generateMarkdownReport(reportData);
  await writeFile(filepath, markdown, 'utf-8');

  return filepath;
}
